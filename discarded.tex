
\makeatletter
\newcommand{\namestack}[1]{%
  \def\dolist##1{\expandafter\@dolist##1,\@eol}%
  \def\@dolist##1,##2\@eol{%
    \begingroup\setbox0=\hbox{##1\unskip}\ifdim\wd0=0pt\endgroup\else\endgroup\name{\ignorespaces##1\unskip}\fi%
    \ifx\@eol##2\@eol\else\\\@dolist##2\@eol\fi}%
  \substack{\dolist{#1}}%
}
\makeatother


\section{Dims vs Named Tuples as first-class objects}
\label{sec:tsalib}

\begin{description}
\item[NS] I think that this section is really about whether we want dims (and shapes) as first class objects vs named tuples. Also, if operators over dims and shapes help make the description more modular, expressive. The notation does not assume (as far as I can see) that names and types are linked globally -- different dims may have same name, different types.
\item[DC] I see; I've made some changes in \S\ref{sec:definitions} that go a bit in this direction. Namely, a shape in \S\ref{sec:definitions} is a set of pairs like $(\name{foo}:100)$, which correspond to what are called here dims.
\end{description}

\begin{description}
\item[DC] But I have the following worries:
\begin{itemize}
\item Two dim variables that use the same identifier could be confusing. This is a level of indirection that I feel is more than usual in math.
\item If the index set is part of the dim, how do we handle things like sequences of variable length?
\end{itemize}
\item[NS] For variable length sequence, how about each element having its own dim? We may have many dim variables - is that a problem?
\item[SR] One case that I struggle with, and they discuss in the DEX paper is stenciling / convolution. For instance after a 2d conv the `height` dimension goes from 28 to 26 because of corner cases. Should that still be `height`? What about after pooling if it goes to 13?
\item[DC] I think yes, the name can stay the same.
\item[NS] Same name for different dim sizes does not seem right. dim operators (defined below) should handle this, e.g. tensor of dim $h$ transforms to dim $(h - 2)$.
\item[SR] So I think I am with DC that names are not types. This would be a good example where they diverge allowing for a valid contraction whose type fails. 
\item[NS] SR, could you elaborate on what you mean by "a valid contraction whose type fails". 
\item[SR] if you have two tensors with a `height` dim (maybe one is after a 2D conv so it is slightly smaller), but they are of different sizes, then trying to take $\ndot{}$ of them would fail.  
\end{description}

\subsection*{Dim, Expressions, Operators}
\newcommand{\binop}{\star} %pick better symbol
\newcommand{\opmult}[1]{\underset{#1}{\odot}}
\newcommand{\ndim}[1]{{\tt #1}}
\newcommand{\dimset}{{\mathcal D}}

A dim is a tuple $\ndim{u}$ = $(s, e)$, where $s$ is an identifier, $e$ is a {\it size-expression}. Intuitively, attach a name $s$ to an expression $e$ over dim {\it sizes}. Base case: if we label a size symbol $h$ with a name symbol $head$, we get $\ndim{u} = (head, h)$. 
In general, can do arithmetic: $\ndim{u'} = (concat\_dim, d + \dmodel)$.

Intuition: define an initial set of dims. Define other dims in the program as expressions over the initial set. Expressions help track the dependency (provenance) of each dim.
Another option is to call the base case as dim and the compound terms as dim expressions.

A size expression $e$ given by following (standard) grammar: 
\begin{itemize}
    \item $e_i \binop e_j$, $e_i$, $e_j$ are size expressions
 \item size symbols $h$, $d_v$, $\dmodel$ etc, constant $c$ (terminals)
\end{itemize}

A dim $\ndim{u}$ has a similar grammar. Base case is a dim $\ndim{u} = (s, h)$, where $h$ is a size symbol or constant. Define operators over dim, e.g., $\ndim{u_i} \binop \ndim{u_j}$. \\
 One way to do this:

Given $\ndim{u_i} = (s_i, e_i)$, $\ndim{u'} = \ndim{u_i} + \ndim{u_j} = (s', e')$, where $s'$ is a {\it fresh} name, $e' = e_i + e_j$.

Equality of dims. $\ndim{u} = \ndim{u'}$ iff $\ndim{u}.s = \ndim{u'}.s$ and $\ndim{u}.e$ = $\ndim{u'}.e$.

TODO: given a context (size symbols mapped to constant), define {\it evaluation} rules for  both $u$ and $e$.

\newcommand{\nshape}{S}
\newcommand{\nsset}{\mathcal{S}}
A {\it named shape} $\nshape = (\ndim{d_1}, \ndim{d_2}, \ldots, \ndim{d_n})$ is an unordered tuple of dims. A {\it well-formed} named shape must satisfy additional constraints, e.g., no two dims in $\nshape$ have the same name symbol.

A {\it tensor} is a tuple $(\nshape, F)$, where $\nshape$ is a named shape and $F$ is a field. Let the set of named shapes be $\nsset$ and the set of dims be $\dimset$.

We define operators over named shapes.
\begin{itemize}
    \item substitute $\ndim{d}$ by $\ndim{d'}$ in shape $\nshape$: $\nshape_{\ndim{d} \rightarrow \ndim{d'}}$.
    
    \item contraction $\opmult{\cdot}: \nsset \times \nsset \times 2^\dimset \rightarrow \nsset$. e.g., if $\nshape_1$ = $(\ndim{head}, \ndim{emb}, \ndim{key})$ and $\nshape_2$ = $(\ndim{time}, \ndim{emb})$, then $\nshape_3 = S_1 \opmult{\{\ndim{emb}\}} S_2 = (\ndim{head},\ndim{time}, \ndim{key})$. Allows multiple dims, hence $2^\dimset$. The definition of $\opmult{}$ specifies what to do for common dims between $S_1$ and $S_2$: keep $\ndim{head}$, remove $\ndim{emb}$.
    
    \item $\text{Attention} ( (\ndim{time'}, \ndim{key}), (\ndim{time}, \ndim{key}), (\ndim{time}, \ndim{val}) ) = (\ndim{time'}, \ndim{val})$. This looks more like a rewrite equation.

\end{itemize}

\begin{description}
\item[DC] In the contraction operation $\ndot{emb}$, what is $\name{emb}$? Is it a variable standing for a dim, or is it an identifier? How does the operator know which indices to contract? Indices with the same dim, or the same identifier?
\item[NS] To find {\it matching} dims in the definition of shape contraction, we either use dim equality (implicit matching) or pairs of matching dims are given explicitly.
\item[DC] Another question: what are the constraints on what dims can occur in the same named shape? Is $((\name{foo}, 10), (\name{foo}, 20))$ a well-formed named shape?
\item[NS] I think we are free to add whatever constraints that seem reasonable. e.g., no two dims in a shape have the same name (appears reasonable), or no two dims have the same size (unreasonable)
\item[DC] If I understand correctly, this proposal is taken care of by the fact that the pair $\name{i}:X$ is a ``first-class'' object. If the author wants to, they can define $\ndim{foo} = (\name{foo}:1000)$ and then define a tensor $A \in \mathbb{R}^{\ndim{foo}, \ndim{foo}}$. So I think we can close this section.
\item[NS] Sure, using $\ndim{foo}$ could be an alternate syntax. The doc reads well now, let's close this section.
\end{description}



\subsection{Multiple indices with the same name}

One way to solve the ``duality problem'' is to make indices be ordered and named (like in PyTorch named tensors), and duplicates are allowed:
\begin{align*}
x^{(t)} &\in \mathbb{R}^{\name{emb}: 100} \\
h^{(t)} &\in \mathbb{R}^{\name{state}: 100} \\
A &\in \mathbb{R}^{\name{state}: 100, \name{state}: 100} \\
B &\in \mathbb{R}^{\name{emb}: 100, \name{state}: 100} \\
c &\in \mathbb{R}^{\name{state}: 100} \\
h^{(t+1)} &= \tanh\left( A \ndot{state} h^{(t)} + B \ndot{emb} x^{(t)} + c \right)
\end{align*}
The $\ndot{a}$ operator contracts the \emph{last} index named $\name{a}$ in its left operand with the \emph{first} index named $\name{a}$ in its right operand. (This is like \verb|tensordot|.) It's unclear what the meaning of $\ndot{a,a}$ would be -- it would contract the last two indices named $\name{a}$ in the left operand with the first two indices named $\name{a}$ in the right operand, but which goes with which?

Having two indices with the same name makes that index behave like a matrix. It's difficult to imagine why one would want three or more indices with the same name.